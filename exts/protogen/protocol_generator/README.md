Protogen, the Protocol Generator
================================

The MDI protocol generator aims to simplify the communication protocol between MDI devices and servers. Given a JSON file that describes a protocol, Protogen generates Ruby or Java code to be used in the server SDK VM (and Ragent) or on the device.

The issue addressed by Protogen is: the developer should not have to deal with "low-level" details such as writing serialization code or managing cookies. The developer using Protogen code simply has to write the callbacks he defined in its protocol.

The generated code takes care of the following problems:

* efficient serialization of messages (currently using msgpack)
* calling user-defined callbacks when needed
* error handling (timeouts and so on)
* managing the state machine on the device (server is stateless)
* cookies
* splitting big messages sent from the server and assembling them back on the device


## Dependencies

You will need Ruby version 1.9 (Protogen has been tested on MRI Ruby 1.9.3) or superior.

If you want to generate and compile the device-side Java code, you will need a Java 6 development environment. You will need the `jar` and `javac` java build tools installed on your system (they come with any Java 6 JDK). It also needs the device core `.jar`. You can find a default `jar` in `config/mdi-framework-3.X.jar`. If you wish to use your own `jar`, you can define it in your configuration file.

Do not use Java 7 to compile Protogen unless you want to encounter strange errors when running your app...

(deactivated) You will also need doxygen installed, if you wish to have documentation aside from generated code.

## Compatibility information

Protogen generated device code has been tested with version 3.4.1 of the core and is incompatible with earlier versions.

Server code has been tested with the version v0.2.5-rc038 of the server SDK VM.

## Usage

Protogen is basically a Ruby script that takes as input protocol description files and a configuration file, and outputs either Ruby code (to be used with Ragent or the server SDK) or a compiled Java `jar` (to be used on the device), depending on the configuration file.

To generate code, you need to launch:

    bundle exec ruby protogen.rb <protocol_file_path_1> <protocol_file_path_2> <configuration_file_path>

where

* `protocol_file_path_X` is the path to a protocol file. If you generate Ruby code, you can provide several versions of the same protocol, and the generated Ruby code will be able to handle all these versions. If you generate device code, you must provide only one protocol file.
* `configuration_file_path` is the path to the file which will configure how your code will be generated.

## Protocol file

See `doc/protocol_file.md` for a description of the protocol file.

## Configuration file

This file describe how the code will be generated. It can either be written by the user, if he wants to generate code on his own, or be generated by a specific platform (the server SDK VM for example). They use the JSON syntax.

### Device configuration file

    {
      "plugins":  [
        "mdi_sdk_vm_device_java"
      ],
      "agent_name":"ProtogenAgentTest",
      "device_output_directory":"sdk_defined_directory",
      "java_package":"com.mdi.test.protogen.avril11", /* the name of the java package in which all the code will be generated. */
      "keep_java_source":false, /* whether the source files are included in the release (they will be copied in the output folder.*/
      "keep_java_jar":true, /* whether the jar is included in the release */
      "mdi_framework_jar":"/home/guillaume/sdk/MDI-SDK-3.0.14-rc1-linux-x86_64/plugins/com.mdi.project.fw_3.0.13.20121016153400/mdi-framework-3.X/simulator/mdi-framework-3.X.jar" /* path to the mdi framework. Used only when compiling java during code generation and to override default framework in config.*/
    }

### Server configuration file

    {
      "plugins":  [
        "mdi_sdk_vm_server_ruby"
      ],
      "agent_name":"ProtogenAgentTest",
      "server_output_directory":"sdk_defined_directory",
      "generate_ruby_documentation": false /* whether to invoke YARD to generate documentation for the Ruby generated code */
    }

## Use the Protogen-generated code ###

The file `doc/protogen_for_the_user.md` explains how a developer can use the Protogen generated code.

## Known issues

* [Major] The cookies system needs more work. The main issue with the current one is that it maintains a state in Redis (passwords) shared between agents that is necessary to read cookies. However, this assumes that 1) the Redis cache is reliable and permanent (untrue, by the very concept of a cache it could be flushed at any moment) 2) the Redis cache is shared between all agents (true... for now, one should not rely on it). Basically, the fact that the cookie system works is a coincidence. Consider moving any permanent, shared storage to the MongoDB database.

* As of core version 3.4.0, the `Message` and `Query` classes do not guarantee any ordering of the callbacks calls. For instance, the onResponseTimeOut callback could be called just before a onReply callback. Furthermore, the callback calls could be interleaved. This is considered a limitation of the `MessageGateHelper` and will be solved in a future version of the core. For now, Protogen does not offer any workaouround for this, as 1) the probability of this actually happening is low and 2) there is a plan to solve this in the core.

* When generating device code, Protogen will exit with status 0 (success) even if the compilation of the generated Java code failed. Protogen will output the result of the compilation, check that the compilation was successful. Note that if there are no bugs in Protogen, the compilation should never fail. But in the real life...

* Protogen sometimes throws a `NullPointerException` when handling large messages

```
2013/11/12 17:06.30  EventDispatcher::EventListenerExec::run: unexpected error java.lang.NullPointerException
2013/11/12 17:06.30  java.lang.NullPointerException
2013/11/12 17:06.30   at java.io.OutputStream.write(OutputStream.java:82)
2013/11/12 17:06.30   at com.test.sequences.Splitter.assemble(Splitter.java:81)
2013/11/12 17:06.30   at com.test.sequences.Splitter.assemble(Splitter.java:70)
2013/11/12 17:06.30   at com.test.sequences.Codec.decode(Codec.java:95)
2013/11/12 17:06.30   at com.test.sequences.Sequences$SimpleQuestionToServer$FirstShotForSimpleQuestionToServer.onReply(Sequences.java:468)
2013/11/12 17:06.30   at com.mdi.tools.helpers.messagegate.Query.getReply(Query.java:278)
2013/11/12 17:06.30   at com.mdi.tools.helpers.messagegate.MessageGateHelper.treatMessageReception(MessageGateHelper.java:631)
2013/11/12 17:06.30   at com.mdi.tools.helpers.messagegate.MessageGateHelper.dispatchEvent(MessageGateHelper.java:593)
2013/11/12 17:06.30   at com.mdi.tools.events.EventDispatcher$EventListenerExec.run(EventDispatcher.java:56)
2013/11/12 17:06.30   at com.mdi.tools.events.EventDispatcher$EventListenerContainer.process(EventDispatcher.java:103)
2013/11/12 17:06.30   at com.mdi.tools.events.EventDispatcher.notifyListener(EventDispatcher.java:574)
2013/11/12 17:06.30   at com.mdi.tools.events.EventDispatcher.run(EventDispatcher.java:618)
```

If you know how to reproduce this exception, please report it, as for now it is not known how to reproduce the error.

## Tests

(Tests are really scarce and now mostly outdated - do not rely on them).

To launch the protogen tests, you simply have to launch the test.rb script at the root of the protogen. Be sure that the sdk vm is up, and that you have released the same version of the protogen on the vm (using for example "./release_sdk.rb -l").
