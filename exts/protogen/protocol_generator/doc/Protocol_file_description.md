# Protocol file description #

A protocol description file is a JSON file that is the input source for Protogen.

The root object of this document must have these mandatory attributes:

* "protocol_version": (int) must be incremented each time a change is made to the protocol file (to ensure the device and the server have the same version of the protocol).
* "protogen_version": (int) for future use, set it to 1 for now.
* "package": (string) Java-style package name using only lowercase letters. Used to namespace the protocol.
* "messages": defines the messages exchanged between the server and the device. A message is merely a data format.
* "sequences": defines the sequences. A sequence is a succession of message exchanges between device and server.
* "cookies": defines cookies attached to messages (disclaimer: cookies functionnality has not been fully tested).
* "name": (string) name of the protocol. Must begin with an uppercase letter.

Optional attributes can be defined:

* generic_error_callback: (string) callback to be called when an error occured and there is no more specific appropriate callback. Must be defined on the global sequence controller.
* out_of_sequence_callback: (string) callback to be called when a Protogen message was received and decoded by the device, but is not associated with any running sequence (for instance, this could happen if the device sends a query to the server, then reboots, then receives the response). If not defined, Protogen will simply drop the message.

Template of the protocol file:

   {
      "name": "MyProtocolName",
      "protocol_version": 1,
      "protogen_version": 1,
      "package":"com.test.example",
      "messages": {},
      "cookies": {},
      "sequences": {}
   }

## Complete example

See the `protogen.example.json` file for an example protocol file. You may also want to read the `README.md` at the root of the repository if you want an overview on Protogen, and the `for_the_user.md` file to see how to develop using the code generated by Protogen.

## Pseudo-UML overview

"-->" is the ASCII art for aggregation

                  +-------------------------------------+
                  |Cookie                               |
                  |-------------------------------------|
                  |name: string                         |
                  |_send_with: array<string>            |
                  |_secure: string (default to "high")  |
                  |_validity_time: int (default to 3600)|
                  |_docstring: string                   |
                  +-------------------------------------+
                     |                            |
                     |                            |
                     |                            |
                     |                            |
                     |                            |
                     |                            |
                     |                            |
          send_with  | 1..*                  1..* | fields (only basic types are allowed)
                     v                            v
      +------------------+                      +---------------------------------------------------+
      |      Message     |                      |    Field                                          |
      |------------------|                      |---------------------------------------------------|
      |name: string      |                      |name: string                                       |
      |_way: string      |1                 1..*|type: string (a basic type or another message name)|
      |_docstring: string|<---------------------+modifier: string                                   |
      |                  |                fields|docstring: string                                  |
      |                  |                      |array: boolean                                     |
      |                  |                      |                                                   |
      +--------+---------+                      +---------------------------------------------------+
               |
   message_type|1
               |
               |
               |
               |
               |
               |
               | 1..*
               v
   +---------------------------------+                           +------------------------+
   |     Shot                        |                           |  Sequence              |
   |---------------------------------|                           |------------------------|
   |name: string                     |1..*                     1 |name: string            |
   |way: string                      +-------------------------->|aborted_callback: string|
   |next_shots: array<Shots>         |shots                      |first_shot: Shot        |
   |received_callback: string        |                           |docstring: string       |
   |ack_timeout_callback: string     |                           |                        |
   |cancel_callback: string          |                           +------------------------+
   |response_timeout_callback: string|
   |send_timeout_callback: string    |
   |server_nack_callback: string     |
   |server_error_callback: string    |
   |timeouts: object                 |
   |retry_policy: object             |
   |multiple: boolean                |
   |all_received_callback: string    |
   +---------------------------------+

## Validation schema

The input file will be validated against the `GENERAL_SCHEMA` definition found in `lib/protocol_generator/schema.rb`. However, this schema does not define yet all the conditions for the protocol file to be valid. The Protogen parser itself will perform additionnal validation.

## Global requirements ##

* All callback names must begin with an underscore letter.
* A basic type must be one of the following: 'int', 'bool', 'float', 'bytes', 'string'

## Messages ##

### Example ###

   {
      "name": "MyProtocolName",
      "protocol_version": 1,
      "messages": {
        "PoiRequest": {
          "_way":"toServer",
          "_docstring":"Sent when the device wants to know about a POI",
          "poi_name":{"type":"string", "modifier":"required", "docstring":"my documentation"}

        },

        "PoiList": {
          "_way":"toDevice",
          "_docstring":"A list of POIs",
          "pois":{"type":"string", "modifier":"required", "docstring":"my documentation", "array":true}

        },

      }
      "cookies": {},
      "sequences": {}
   }

### Definition ###

A message is a data container. Its name must be unique (in the protocol file) and must begin with an uppercase letter. The message name is identified by the key representing the message in the JSON format.

The attributes of a message must begin with a lowercase letter or an underscore.

The attributes of a message that begin with an underscore are configuration fields. The other attributes are "regular" fields.

### Configuration fields ###

* "_way" (mandatory): String. can be "toServer", "toDevice", or "both". Defines which can be the receiver of this message.
* "_docstring" (optional): a string describing your message.

### Fields definition ###

Examples:

   "my_data_field":{"type":"string", "modifier":"required", "docstring":"my documentation"}

   "my_array":{"type":"string", "modifier":"required", "docstring":"my documentation", "array":true}

* "type" (mandatory): (string) can be one of the basic types or another message name
* "modifier" (mandatory): (string) can be "required" or "optional"
* "docstring" (optional): (string) a documentation string
* "array" (optional): (boolean) if set to true (default value is false), the field is an array rather than a single value. Items of the array are of the type declared in "type".

## Sequences ##

### Example ###

   {
      "name": "MyProtocolName",
      "protocol_version": 1,
      "protogen_version": 1,
      "messages": {
        "PoiRequest": {
          "_way":"toServer",
          "poi_name":{"type":"string"}
        },

        "PoiList": {
          "_way":"toDevice",
          "pois":{"type":"string", "array":true}
        }
      },
      "sequences": {
        "AskForPois": {
          "aborted_callback":"aborted",
          "first_shot":"AskToServer",
          "shots": {
            "AskToServer": {
              "way":"toServer",
              "message_type":"PoiRequest",
              "received_callback":"server_callback",
              "next_shots":["ResponseFromServer"]
            },
            "ResponseFromServer": {
              "way":"toDevice",
              "message_type":"PoiList",
              "received_callback":"deviceCallback"
            }
          }
        }
      },
      "cookies": {}
   }


### Definition ###

A sequence describes a exchange of messages between the device and the server. While a message describes the structure of the information sent on the wire, a sequence describes a serie of exchanged messages.

A sequence name must begin with an uppercase letter. A sequence definition must contain at least two attributes:

* "first_shot" (string): the name of the shot that will begin the sequence
* "shots" (array of Shots): a "shot" is the device sending a message to the server or the server sending a message to the device. It defines the callbacks associated with it and other related data.

Additionnally, a sequence can define optional fields:

* "aborted_callback": (string) will be called if Protogen encounters an error in the sequence before its completion.
* "docstring": (string) to describe the purpose of the sequence

#### Shots

A shot name must begin with an uppercase letter. The shot name is the key used to defined the shot. A shot definition must have the following fields:

* "way": "toDevice" or "toServer".
* "message_type" (string): a message name that will carry the data of this shot. The message "_way" must be compatible with the sequence "way".
* "received_callback" (string): a callback trigerred on the receiver when it receives the message.

If the shot is not the end of the sequence, the field "next_shots" (array of strings) must also be defined. It is an array that defines which messages can be sent in response to this shot. Each element in this array must be a message name.

When it receives a message, the receiver chooses one (and only one) of the available next shots to continue the sequence.

Important: next shots must have different associated message types (example: if ShotA has ShotB and ShotC as next shots and ShotB and ShotC have "message_type" set to "MessageA" then the sequence is invalid).

Additional optional attributes can be defined if the sender is the device:

* ack_timeout_callback
* cancel_callback
* response_timeout_callback
* send_timeout_callback
* server_nack_callback
* server_error_callback (when the server notifies that the agent processing the request raised an exception, so the device does not wait for the timeout)
* send_success_callback

If these callbacks are not explicitely defined, Protogen will default to a basic callback that just prints the event in the logs (or does nothing for the "send_success_callback").

Optional attributes can be defined if the sender is the server:

* "multiple" (boolean): if true, the servers can send several messages at once for this shot. The device callback "received_callback" will be trigered each time. This callback is given the current message number, and the expected total number of messages. The current message number matches the index in the array sent by the server but note that the ordering of received messages is unknown. An additional callback "all_received_callback" (string) must be defined for such a shot. It will be called when all messages have been received and the sequence is ready to be continued. If omitted, default to false. Due to a Protogen limitation, a sequence can not currently start with a multiple shot (but you can still use an array attribute in the first message)

Callbacks names must be unique in the sequence.

##### Timeouts #####

A shot sent from the device can have associated timeouts. If no timeouts are defined, a 60 seconds default timeout is used.

    "AskToServer": {
      "way":"toServer",
      "message_type":"PoiRequest",
      "received_callback":"server_callback",
      "next_shots":["ResponseFromServer"],
      "timeouts": {
        "send": 42,
        "receive": 43
      }
    }

Timeout values are given in seconds.

The "send" timeout is the maximum duration the device has to send a message to the server.
The "receive" timeout is the maximum duration the device will wait for the reply to one of its queries. If Protogen has to split messages, this is the maximum duration for receiving *all* the message parts. If the shot has "multiple: true" set, then the receive timeout is the maximum duration for retrieveing *all* messages.

One can not define timeouts for shots that are sent to the device.
The "receive" timeout can only be defined if a server reply is expected i.e. if at least one "next_shot" is defined.

##### Retry policy #####

One can also supply a simple "retry policy" for shots that are sent to the server and have at least a "next_shot".

    "AskToServer": {
      "way":"toServer",
      "message_type":"PoiRequest",
      "received_callback":"server_callback",
      "next_shots":["ResponseFromServer"],
      "retry_policy" : {
        "delay":10,
        "attempts": 5
      }
    }

In the above example, if the device does not receive an answer to its query after for any reason (response or send timeout expired, no server ACK...), then it will wait 10 seconds and retry sending the message. It will use 5 attempts to receive an answer, and call the "aborted" callback once these attempts are exhausted.

A retry policy has two attributes:

* "delay" (mandatory, int): duration the device will wait before sending a new message. This duration starts *once the device decided it will not receive a response*, and so it is not the duration between two successive sendings.
* "attempts" (optional, int): number of attempts before aborting the sequence. If missing, the device will perform an infinite amount of retries (and thus, will never call the "aborted" callback because of a timeout). Must be > 1.

##### A note on callbacks #####

There are several situations in which the server will not answer to the device message. When such a situation occurs, the corresponding callback (defined in the shot) will be called.
Once this callback is executed, Protogen checks for the existence of a retry policy in the shot. If the policy dictates that there is no attempt left, or if there is no retry policy, then Protogen will abort the sequence and call the "aborted" callback (defined at the sequence level).
Thus, the error callbacks such as "send_timeout_callback" will be called even if, because of the retry policy, the sequence did not abort.

## Cookies ##

Cookies are pieces of data generated by a server that are sent along a message, are stored on a device, and then sent with appropriate messages. They are encrypted data (enabled by default), and may only be decrypted by the server itself.

Cookies fields are defined the same way as messages fields, except with the following restrictions:

* A cookie can not have more than 10 fields (all the fields must be basic types) and it is recommended to not have more than 2 or 3 fields.
* Array fields are not allowed either.

Cookies have different configuration fields than messages.

Mandatory conf fields:
* "_send_with" (array of strings): list all messages that may carry this type of cookie. If the device owns the corresponding cookie, it will send the cookie along with the specified messages.

Other possible fields:

* "_secure" :
  * "high" (default): cookies are encrypted and may not be seen by the devices
  * "low" : cookies aren't encrypted, but carry a signature that assert their authenticity (not implemented)
  * "none" : no encryption, no signature (not implemented)
* "_validity_time" : (in seconds, int) time during which the cookie is considered valid. After this, it will be discarded by the server when received, and by the device when sent. Default: 3600s.
* "_docstring" (string): describe the cookie.

Protogen will currently accept any of "high", "low" or "none" for the `_secure` attribute, but will always behave as if "high" was provided.

Example:

    "Cart": {
      "_secure":"low",
      "_send_with":["Person"],
      "lastitem": {"type":"int", "modifier":"required"},
      "purchased":   {"type":"bool", "modifier":"required"}
    }

# Final note #

Currently, some of the above is not actually enforced by Protogen, but do not rely on it.